"""
Interactive Perspective Adjustment
==================================

Most of the times, setting the theta, phi, the rotation and distance of the
camera can be difficult for normal human when we are just given the coordinate
of the molecule. This module is designed to facilitate this process.

The basic idea is to have a small class holding the information about a plot.
This class will expose methods for changing the perspective, so that whenever a
parameter is changed, a new plot is going to be generated by calling the actual
ccpoviz program. So if we have an image viewer with the dynamic reloading
capability, like the eye of gnome from the gnome project. the perspective of
the plotting can be changed interactively.

Also a wrapper main function is provided, which is able to surrender to an
interactive python interpreter with the perspective object already defined
based on the command line arguments, which should have input file giving the
perspective and the name of an output file for putting the changed perspective
in the first two positions. The follows the entire command line arguments to be
used for calling the main ccpoviz program.

"""

from __future__ import print_function

import sys
import re
import subprocess
import code

import pystache

from .util import terminate_program


OPS = [
    'theta', 'phi', 'rotation', 'distance'
    ]
DEFAULT_PERSPECTIVE = {
    'theta': 0.0,
    'phi': 0.0,
    'rotation': 0.0,
    'distance': 10.0,
}


def find_ops(op_names, lines):

    """Finds a camera option from the lines

    The lines will be searched for the camera option, and the new lines with
    the actual option changed to mustache flags and the initial value of the
    option be returned.

    """

    pats = [
        re.compile(
            r'^(?P<tag> *"?camera-%s"? *: *)(?P<value>[0-9+-.eE]+) *' % i
            )
        for i in op_names
        ]

    new_lines = []
    init_vals = {i: None for i in op_names}
    for l_i in lines:

        for op_i, pat_i in zip(op_names, pats):
            match = pat_i.match(l_i)
            if not match:
                continue
            else:
                try:
                    init_vals[op_i] = float(match.group('value'))
                except ValueError:
                    terminate_program('Invalid options for camera-%s' % op_i)
                new_lines.append(
                    match.expand(r'\g<tag>{{{%s}}}' % op_i) + '\n'
                    )
                break
        else:
            new_lines.append(l_i)

    for k, val in init_vals.iteritems():
        if val is None:
            terminate_program(
                'No initial value specified for camera-%s' % k
                )

    return new_lines, init_vals


def _gen_change_meth(op_name):

    """Generate a method that is able to change a property

    In this way, we do not have to repeat the same for each property.

    """

    def change_meth(self, incr):
        """Dummy doc string to be changed"""
        setattr(self, op_name, getattr(self, op_name) + incr)
        self.render()
    change_meth.__doc__ = (
        "Changes %s of the current perspective" % op_name
        )

    return change_meth


class IPerspective(object):

    """The interactive perspective class

    The class can be initialized with the command line arguments for the job
    and the name of the temporary file. Then methods can be called to
    manipulate the perspective and generates the output immediately.

    Note that the camera options are assumed to be on separate lines in the
    input perspective file.

    """

    __slots__ = [
        'template', 'temp', 'args'
        ] + OPS

    def __init__(self, ref, temp, args):

        """Initializes the interactive perspective object

        :param ref: The reference file for generating the input
        :param temp: The name of the temporary file
        :param args: A list of strings as arguments for calling the ccpoviz
            main program, including the ccpoviz command

        """

        try:
            ref_f = open(ref, 'r')
        except IOError:
            terminate_program(
                'Reference file %s cannot be opened' % ref
                )
        ref_lines = [i for i in ref_f]
        ref_f.close()

        new_lines, init_vals = find_ops(OPS, ref_lines)
        for op_i in OPS:
            setattr(self, op_i, init_vals[op_i])
        self.template = ''.join(new_lines)

        self.temp = temp
        self.args = args

    def render(self):

        """Renders for the current perspective"""

        render_dict = {
            op_i: getattr(self, op_i)
            for op_i in OPS
            }
        renderer = pystache.Renderer()
        result = renderer.render(self.template, render_dict)
        with open(self.temp, 'w') as temp_f:
            temp_f.write(result)

        return subprocess.call(self.args)

    def print_params(self):

        """Prints the current setting of the parameters out"""

        for op_i in OPS:
            print(
                'camera-%s: %f' % (op_i, getattr(self, op_i))
                )

        return None

    change_theta = _gen_change_meth('theta')
    change_phi = _gen_change_meth('phi')
    change_rotation = _gen_change_meth('rotation')
    change_distance = _gen_change_meth('distance')


def main():

    """The main driver routine for the interactive perspective utility"""

    try:
        ref = sys.argv[1]
        temp = sys.argv[2]
        args = sys.argv[3:]
    except IndexError:
        terminate_program(
            'More arguments are expected!'
            )

    banner = """
    iPerspective facility for ccpoviz
    =================================

    Now you can interactively change the perspective of the camera now.

    Reference file: {ref}
    Temporary file to generate: {temp}
    ccpoviz are going to be called by: {args}

    To change the perspective parameters theta, phi, rotation, distance, just
    call the `change_` methods to the `s` or `scene` object. `render` will
    force a render, and `print_params` will print the current parameters out.

    """.format(
        ref=ref, temp=temp, args=(' '.join(args))
        )

    ipersp = IPerspective(ref, temp, args)
    ipersp.render()
    code.interact(
        banner=banner,
        local={'s': ipersp, 'scene': ipersp}
        )

    return 0
